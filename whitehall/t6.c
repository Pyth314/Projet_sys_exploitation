#include <SDL.h>        
#include <SDL_image.h>        
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>


int main(int argc, char ** argv)
{
    int quit = 0;
    
    SDL_Event event;
    pthread_t thread1;
	int mx,my;
 
    SDL_Init(SDL_INIT_VIDEO); // Initialiser le farmework SDL : Simple Directmedia Layer
 
    SDL_Window * window = SDL_CreateWindow("SDL2 Displaying Image",
        SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 1024+128, 1024, 0); // Definir une fenêtre dans laquel on affichera les reminder (rendu )
 
    SDL_Renderer * renderer = SDL_CreateRenderer(window, -1, 0); // creation d'une fenêtre (dans laquelle on importe des texture)
    //SDL_Surface * image = SDL_LoadBMP("whitehall_1024x1024.bmp");
    
    
    SDL_Surface * image = IMG_Load("whitehall_1024x1024.png"); // Surface théorique impossible à afficher
    SDL_Surface * pawn = IMG_Load("pawn.png");
    
    SDL_SetColorKey( pawn, SDL_TRUE, SDL_MapRGB( pawn->format, 0, 0, 0 ) ); // Suprimer les pixel des fonds gimp pour faire des objet visuel (image carré + fond transparent)
    //SDL_Surface * pawn = SDL_LoadBMP("pawn.bmp");
    SDL_Surface * rond = IMG_Load("rond.png");
    SDL_SetColorKey( rond, SDL_TRUE, SDL_MapRGB( rond->format, 0, 0, 0 ) );
    //SDL_Surface * rond = SDL_LoadBMP("rond.bmp");
    SDL_Texture * texture = SDL_CreateTextureFromSurface(renderer, image); // Creer une surface affichable en la contextualisant dans la fenêtre render
    SDL_Texture * texture_pawn = SDL_CreateTextureFromSurface(renderer, pawn);
    SDL_Texture * texture_rond = SDL_CreateTextureFromSurface(renderer, rond);
    
	SDL_SetTextureAlphaMod(texture_rond,128); // Mettre en semi Transparent [0 transparent, 255 image normalle]
 
    while (!quit)
    {
        //SDL_WaitEvent(&event);
 
	if (SDL_PollEvent(&event)) // Sonder les évènements
	{
		//printf("un event\n");
        	switch (event.type)
        	{
            		case SDL_QUIT: // évènement quitter
                		quit = 1;
                		break;
                    case  SDL_MOUSEBUTTONDOWN: // évènement de clique existe aussi SDL_MOUSEBUTTONUP
                        SDL_GetMouseState( &mx, &my ); // récupération des coordonnées
                        printf("mx=%d my=%d\n",mx,my);
                        break;
        	}
	}

        SDL_Rect dstrect = { 0, 0, 1024, 1024 }; // creer un rectangle d'affichage (coordonnée d'affichage,)
        //SDL_Rect srcrect_pawn = { 0, 0, 87, 131 };
        SDL_Rect dstrect_pawn = { 100, 100, 87, 131 };
        SDL_Rect dstrect_rond = { 300, 300, 200, 200 };

        SDL_RenderCopy(renderer, texture, NULL, &dstrect);

        //SDL_RenderCopy(renderer, texture, &srcrect, NULL);
        //SDL_RenderCopy(renderer, texture, NULL, NULL);
        SDL_RenderCopy(renderer, texture_pawn, NULL, &dstrect_pawn); // Charger la textures dans le render selon la structure d'image  (coordonnée, dimension)
        SDL_RenderCopy(renderer, texture_rond, NULL, &dstrect_rond);
        
        
        SDL_RenderPresent(renderer); //Afficher le rendu (render) à dans l'écran de
    }
 
    // Libérer toute les couche de traitement graphique
    SDL_DestroyTexture(texture);
    SDL_FreeSurface(image);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
 
    SDL_Quit(); // Effacer le context SDL
 
    return 0;
}
