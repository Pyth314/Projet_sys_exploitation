/*
** fork1.c -- demonstrates usage of fork() and wait()
*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main(void)
{
	pid_t pid;
	int rv;

	switch(pid = fork()) {
	case -1:
		perror("fork");  /* something went wrong */
		exit(1);		 /* parent exits */

	case 0:
		printf(" CHILD: This is the child process!\n");
		printf(" CHILD: My PID is %d\n", getpid());
		printf(" CHILD: My parent's PID is %d\n", getppid());
		printf(" CHILD: Enter my exit status (make it small): ");
		scanf(" %d", &rv);
		printf(" CHILD: I'm outta here!\n");
		exit(rv);

	default:
		printf("PARENT: This is the parent process!\n");
		printf("PARENT: My PID is %d\n", getpid());
		printf("PARENT: My child's PID is %d\n", pid);
		printf("PARENT: I'm now waiting for my child to exit()...\n");
		wait(&rv);
		printf("PARENT: My child's exit status is: %d\n", WEXITSTATUS(rv));
		printf("PARENT: I'm outta here!\n");
	}

	return 0;
}

////////////////////////////////////////////////////////////////////////////

/*
** pipe3.c -- a smartest pipe example
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(void)
{
	int pfds[2];

	pipe(pfds);

	if (!fork()) {
		close(1);       /* close normal stdout */
		dup(pfds[1]);   /* make stdout same as pfds[1] */
		close(pfds[0]); /* we don't need this */
		execlp("ls", "ls", NULL);
	} else {
		close(0);       /* close normal stdin */
		dup(pfds[0]);   /* make stdin same as pfds[0] */
		close(pfds[1]); /* we don't need this */
		execlp("wc", "wc", "-l", NULL);
	}

	return 0;
}

////////////////////////////////////////////////////////////////////////////

/* sig_talk.c --- Example of how 2 processes can talk */
/* to each other using kill() and signal() */
/* We will fork() 2 process and let the parent send a few */
/* signals to it`s child  */

/* cc sig_talk.c -o sig_talk  */

#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

void sighup(); /* routines child will call upon sigtrap */
void sigint();
void sigquit();

int main()
{ int pid;

  /* get child process */
  
   if ((pid = fork()) < 0) {
        perror("fork");
        exit(1);
    }
    
   if (pid == 0)
     { /* child */
       signal(SIGHUP,sighup); /* set function calls */
       signal(SIGINT,sigint);
       signal(SIGQUIT, sigquit);
       for(;;); /* loop for ever */
     }
  else /* parent */
     {  /* pid hold id of child */
       sleep(3); /* pause for 3 secs */
       printf("\nPARENT: sending SIGHUP\n\n");
       kill(pid,SIGHUP);
       sleep(3); /* pause for 3 secs */
       printf("\nPARENT: sending SIGINT\n\n");
       kill(pid,SIGINT);
       sleep(3); /* pause for 3 secs */
       printf("\nPARENT: sending SIGQUIT\n\n");
       kill(pid,SIGQUIT);
       sleep(3);
     }
}

void sighup()

{  
   printf("CHILD: I have received a SIGHUP\n");
}

void sigint()

{ 
   printf("CHILD: I have received a SIGINT\n");
}

void sigquit()

{
  exit(0);
}

////////////////////////////////////////////////////////////////////////////

#include <string.h> 
#include <stdlib.h> 
#include <stdio.h> 
#include <ctype.h> 

#include <sys/types.h> 
#include <sys/ipc.h> 
#include <sys/msg.h> 

#define CLEF_REQUETES         0x00012345
#define CLEF_REPONSES         0x00012346 
#define LG_MAX                512 

struct msgform { 
    long mtype; 
    char mtext[ LG_MAX ]; 
    } 
    msg; 

int main(void) { 
    int res, i; 
    int frequete, freponse; 

    frequete = msgget(CLEF_REQUETES, 0700 | IPC_CREAT); 
    if (frequete == -1) { perror("msgget"); return (EXIT_FAILURE); } 

    freponse = msgget(CLEF_REPONSES, 0700 | IPC_CREAT); 
    if (freponse == -1) { perror("msgget"); return (EXIT_FAILURE); } 

/*
    printf("Waiting a request...\n");
    res = msgrcv(frequete, & msg, LG_MAX, 0, 0); 
    if (res == -1) { perror("msgrcv"); exit(0); } 

    for(i=0; i < strlen(msg.mtext); i++) 
        msg.mtext[i] = toupper(msg.mtext[i]); 
    res = msgsnd(freponse, & msg, strlen(msg.mtext) + 1, 0); 
    if (res == -1) { perror("msgsnd"); exit(0); } 
*/

    printf("Waiting for requests...\n");
    while (1)
    {
    res = msgrcv(frequete, & msg, LG_MAX, 0, 0); 
    if (res == -1) { perror("msgrcv"); exit(0); } 

    for(i=0; i < strlen(msg.mtext); i++) 
        msg.mtext[i] = toupper(msg.mtext[i]); 
    res = msgsnd(freponse, & msg, strlen(msg.mtext) + 1, 0); 
    if (res == -1) { perror("msgsnd"); exit(0); } 
    }

    return (EXIT_SUCCESS); 
    }

////////////////////////////////////////////////////////////////////////////

#include <stdlib.h> 
#include <stdio.h> 
#include <string.h> 

#include <unistd.h> 
#include <sys/types.h> 
#include <sys/ipc.h> 
#include <sys/msg.h> 

#define CLEF_REQUETES         0x00012345
#define CLEF_REPONSES         0x00012346 
#define LG_MAX                512 

struct msgform { 
    long mtype; 
    char mtext[ LG_MAX ]; 
    } 
    msg; 

int main(void) { 
    int res; 
    int frequete, freponse; 

    frequete = msgget(CLEF_REQUETES, 0700 | IPC_CREAT); 
    if (frequete == -1) { perror("msgget"); return (EXIT_FAILURE); } 

    freponse = msgget(CLEF_REPONSES, 0700 | IPC_CREAT); 
    if (freponse == -1) { perror("msgget"); return (EXIT_FAILURE); } 

    msg.mtype = getpid(); 
    strcpy(msg.mtext, "Hello"); 
    res = msgsnd(frequete, & msg, strlen(msg.mtext) + 1, 0); 
    if (res == -1) { perror("msgsnd"); exit(0); } 

    res = msgrcv(freponse, & msg, LG_MAX, getpid(), 0); 
    if (res == -1) { perror("msgrcv"); exit(0); } 

    printf("result : %s\n", msg.mtext); 
    return (EXIT_SUCCESS); 
    }

////////////////////////////////////////////////////////////////////////////

/*
** speak.c -- writes into a FIFO
*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#define FIFO_NAME "fifo_main"

int main(void)
{
	char s[300];
	int num, fd;

	mknod(FIFO_NAME, S_IFIFO | 0666, 0);

	printf("waiting for readers...\n");
	fd = open(FIFO_NAME, O_WRONLY);
	printf("got a reader--type some stuff\n");

	while (gets(s), !feof(stdin)) {
		if ((num = write(fd, s, strlen(s))) == -1)
			perror("write");
		else
			printf("speak: wrote %d bytes\n", num);
	}

	return 0;
}

////////////////////////////////////////////////////////////////////////////

/*
** tick.c -- reads data from a FIFO
*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#define FIFO_NAME "fifo_main"

int main(void)
{
	char s[300];
	int num, fd;

	mknod(FIFO_NAME, S_IFIFO | 0666, 0);

	printf("waiting for writers...\n");
	fd = open(FIFO_NAME, O_RDONLY);
	printf("got a writer\n");

	do {
		if ((num = read(fd, s, 300)) == -1)
			perror("read");
		else {
			s[num] = '\0';
			printf("tick: read %d bytes: \"%s\"\n", num, s);
		}
	} while (num > 0);

	return 0;
}

////////////////////////////////////////////////////////////////////////////

/* Processus ecrivain */
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define CLEF 666

#define LONGUEUR_SEGMENT 512 


int main(int argc,char *argv[])
{
  int semaphores;
  int memoirePartagee;
  struct sembuf manipSemaphores[2];
  char *attacheMoi;

  

  if ((memoirePartagee=shmget(CLEF,LONGUEUR_SEGMENT,IPC_CREAT|0666)) == -1)
  {
    puts("Impossible de creer le segment de memoire partagee");
    exit(1);
  }


  if ((semaphores=semget(CLEF,2,IPC_CREAT|0666)) == -1)
  {
    puts("Impossible de creer les semaphores");
    exit(1);
  }

  /* Les deux operations d'initialisation des semaphores sont faites
     en meme temps */

  manipSemaphores[0].sem_num=0; 
  manipSemaphores[0].sem_op=1;

  manipSemaphores[1].sem_num=1;
  manipSemaphores[1].sem_op=1;

  semop(semaphores,manipSemaphores,2);

  /* Operation P(1) sur le premier semaphore => prise de ressource sur la 
     memoire partagee */

  manipSemaphores[0].sem_num=0;
  manipSemaphores[0].sem_op=-1;

  semop(semaphores,manipSemaphores,1);

  puts("Je prends la ressource");fflush(stdout);

  attacheMoi=shmat(memoirePartagee,NULL,0);


  //if ((int)(attacheMoi)==-1)
  if (attacheMoi==(void*)-1)
  {
    puts("Impossible d'attacher !");
    exit(1);
  }
  else
  {
    printf("Adresse de l'attachement : %p \n",attacheMoi);
    strcpy(attacheMoi,"Message a l'adresse de l'autre processus !");
    shmdt(attacheMoi);
    
    /* Operation V(1) sur le premier semaphore => liberation de la ressource
       memoire partagee */
    
    manipSemaphores[0].sem_num=0;
    manipSemaphores[0].sem_op=1;
    semop(semaphores,manipSemaphores,1);
  }


  puts("Attente de l'autre processus");
  fflush(stdout);

  /* Operation Z sur le second semaphore */

  manipSemaphores[0].sem_num=1;
  manipSemaphores[0].sem_op=0;
  semop(semaphores,manipSemaphores,1);
  

  puts("Debloque !");
  fflush(stdout);
 
  /* Suppression des IPC */

  semctl(semaphores,0,IPC_RMID);
  
  shmctl(memoirePartagee,IPC_RMID,0);
  
  
  return 0;

}

////////////////////////////////////////////////////////////////////////////

/* Processus lecteur */

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define CLEF 666

#define LONGUEUR_SEGMENT 512 


int main(int argc,char *argv[])
{
  int semaphores;
  int memoirePartagee;
  struct sembuf manipSemaphores;
  char *attacheMoi;
 

  if ((memoirePartagee=shmget(CLEF,LONGUEUR_SEGMENT,0600)) == -1)
  {
    puts("Impossible d'acceder au segment de memoire partagee");
    exit(1);
  }


  if ((semaphores=semget(CLEF,2,0600)) == -1)
  {
    puts("Impossible d'acceder aux semaphores");
    exit(1);
  }
  
  /* Operation P(1) => on demande à accéder à la ressource */

  manipSemaphores.sem_num=0;
  manipSemaphores.sem_op=-1;

  semop(semaphores,&manipSemaphores,1);

  puts("Je demande a acceder a la ressource");fflush(stdout);

  attacheMoi=shmat(memoirePartagee,NULL,0);


  if (attacheMoi==(void*)-1)
  {
    puts("Impossible d'attacher !");
    exit(1);
  }
  else
  {
    printf("Adresse de l'attachement : %p \n",attacheMoi);
    puts("Contenu de la memoire a l'attachement ");
    puts(attacheMoi);
    shmdt(attacheMoi);
    manipSemaphores.sem_num=0;
    manipSemaphores.sem_op=1;
    semop(semaphores,&manipSemaphores,1);
  }
 

  puts("Deblocage de l'autre processus");
  fflush(stdout);

  /* Debloquer le semaphore en attente se fait 
     a l'aide d'une operation prise de ressource P(1) car la valeur
     courante de celui-ci est 1*/

  manipSemaphores.sem_num=1;
  manipSemaphores.sem_op=-1;
  semop(semaphores,&manipSemaphores,1);
  
  
  return 0;
}
