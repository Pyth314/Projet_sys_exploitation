     1	/*
     2	** fork1.c -- demonstrates usage of fork() and wait()
     3	*/
      	
     4	#include <stdio.h>
     5	#include <stdlib.h>
     6	#include <errno.h>
     7	#include <unistd.h>
     8	#include <sys/types.h>
     9	#include <sys/wait.h>
      	
    10	int main(void)
    11	{
    12		pid_t pid;
    13		int rv;
      	
    14		switch(pid = fork()) {
    15		case -1:
    16			perror("fork");  /* something went wrong */
    17			exit(1);		 /* parent exits */
      	
    18		case 0:
    19			printf(" CHILD: This is the child process!\n");
    20			printf(" CHILD: My PID is %d\n", getpid());
    21			printf(" CHILD: My parent's PID is %d\n", getppid());
    22			printf(" CHILD: Enter my exit status (make it small): ");
    23			scanf(" %d", &rv);
    24			printf(" CHILD: I'm outta here!\n");
    25			exit(rv);
      	
    26		default:
    27			printf("PARENT: This is the parent process!\n");
    28			printf("PARENT: My PID is %d\n", getpid());
    29			printf("PARENT: My child's PID is %d\n", pid);
    30			printf("PARENT: I'm now waiting for my child to exit()...\n");
    31			wait(&rv);
    32			printf("PARENT: My child's exit status is: %d\n", WEXITSTATUS(rv));
    33			printf("PARENT: I'm outta here!\n");
    34		}
      	
    35		return 0;
    36	}
      	
    37	////////////////////////////////////////////////////////////////////////////
      	
    38	/*
    39	** pipe3.c -- a smartest pipe example
    40	*/
      	
    41	#include <stdio.h>
    42	#include <stdlib.h>
    43	#include <unistd.h>
      	
    44	int main(void)
    45	{
    46		int pfds[2];
      	
    47		pipe(pfds);
      	
    48		if (!fork()) {
    49			close(1);       /* close normal stdout */
    50			dup(pfds[1]);   /* make stdout same as pfds[1] */
    51			close(pfds[0]); /* we don't need this */
    52			execlp("ls", "ls", NULL);
    53		} else {
    54			close(0);       /* close normal stdin */
    55			dup(pfds[0]);   /* make stdin same as pfds[0] */
    56			close(pfds[1]); /* we don't need this */
    57			execlp("wc", "wc", "-l", NULL);
    58		}
      	
    59		return 0;
    60	}
      	
    61	////////////////////////////////////////////////////////////////////////////
      	
    62	/* sig_talk.c --- Example of how 2 processes can talk */
    63	/* to each other using kill() and signal() */
    64	/* We will fork() 2 process and let the parent send a few */
    65	/* signals to it`s child  */
      	
    66	/* cc sig_talk.c -o sig_talk  */
      	
    67	#include <stdio.h>
    68	#include <signal.h>
    69	#include <stdlib.h>
    70	#include <unistd.h>
      	
    71	void sighup(); /* routines child will call upon sigtrap */
    72	void sigint();
    73	void sigquit();
      	
    74	int main()
    75	{ int pid;
      	
    76	  /* get child process */
    77	  
    78	   if ((pid = fork()) < 0) {
    79	        perror("fork");
    80	        exit(1);
    81	    }
    82	    
    83	   if (pid == 0)
    84	     { /* child */
    85	       signal(SIGHUP,sighup); /* set function calls */
    86	       signal(SIGINT,sigint);
    87	       signal(SIGQUIT, sigquit);
    88	       for(;;); /* loop for ever */
    89	     }
    90	  else /* parent */
    91	     {  /* pid hold id of child */
    92	       sleep(3); /* pause for 3 secs */
    93	       printf("\nPARENT: sending SIGHUP\n\n");
    94	       kill(pid,SIGHUP);
    95	       sleep(3); /* pause for 3 secs */
    96	       printf("\nPARENT: sending SIGINT\n\n");
    97	       kill(pid,SIGINT);
    98	       sleep(3); /* pause for 3 secs */
    99	       printf("\nPARENT: sending SIGQUIT\n\n");
   100	       kill(pid,SIGQUIT);
   101	       sleep(3);
   102	     }
   103	}
      	
   104	void sighup()
      	
   105	{  
   106	   printf("CHILD: I have received a SIGHUP\n");
   107	}
      	
   108	void sigint()
      	
   109	{ 
   110	   printf("CHILD: I have received a SIGINT\n");
   111	}
      	
   112	void sigquit()
      	
   113	{
   114	  exit(0);
   115	}
      	
   116	////////////////////////////////////////////////////////////////////////////
      	
   117	#include <string.h> 
   118	#include <stdlib.h> 
   119	#include <stdio.h> 
   120	#include <ctype.h> 
      	
   121	#include <sys/types.h> 
   122	#include <sys/ipc.h> 
   123	#include <sys/msg.h> 
      	
   124	#define CLEF_REQUETES         0x00012345
   125	#define CLEF_REPONSES         0x00012346 
   126	#define LG_MAX                512 
      	
   127	struct msgform { 
   128	    long mtype; 
   129	    char mtext[ LG_MAX ]; 
   130	    } 
   131	    msg; 
      	
   132	int main(void) { 
   133	    int res, i; 
   134	    int frequete, freponse; 
      	
   135	    frequete = msgget(CLEF_REQUETES, 0700 | IPC_CREAT); 
   136	    if (frequete == -1) { perror("msgget"); return (EXIT_FAILURE); } 
      	
   137	    freponse = msgget(CLEF_REPONSES, 0700 | IPC_CREAT); 
   138	    if (freponse == -1) { perror("msgget"); return (EXIT_FAILURE); } 
      	
   139	/*
   140	    printf("Waiting a request...\n");
   141	    res = msgrcv(frequete, & msg, LG_MAX, 0, 0); 
   142	    if (res == -1) { perror("msgrcv"); exit(0); } 
      	
   143	    for(i=0; i < strlen(msg.mtext); i++) 
   144	        msg.mtext[i] = toupper(msg.mtext[i]); 
   145	    res = msgsnd(freponse, & msg, strlen(msg.mtext) + 1, 0); 
   146	    if (res == -1) { perror("msgsnd"); exit(0); } 
   147	*/
      	
   148	    printf("Waiting for requests...\n");
   149	    while (1)
   150	    {
   151	    res = msgrcv(frequete, & msg, LG_MAX, 0, 0); 
   152	    if (res == -1) { perror("msgrcv"); exit(0); } 
      	
   153	    for(i=0; i < strlen(msg.mtext); i++) 
   154	        msg.mtext[i] = toupper(msg.mtext[i]); 
   155	    res = msgsnd(freponse, & msg, strlen(msg.mtext) + 1, 0); 
   156	    if (res == -1) { perror("msgsnd"); exit(0); } 
   157	    }
      	
   158	    return (EXIT_SUCCESS); 
   159	    }
      	
   160	////////////////////////////////////////////////////////////////////////////
      	
   161	#include <stdlib.h> 
   162	#include <stdio.h> 
   163	#include <string.h> 
      	
   164	#include <unistd.h> 
   165	#include <sys/types.h> 
   166	#include <sys/ipc.h> 
   167	#include <sys/msg.h> 
      	
   168	#define CLEF_REQUETES         0x00012345
   169	#define CLEF_REPONSES         0x00012346 
   170	#define LG_MAX                512 
      	
   171	struct msgform { 
   172	    long mtype; 
   173	    char mtext[ LG_MAX ]; 
   174	    } 
   175	    msg; 
      	
   176	int main(void) { 
   177	    int res; 
   178	    int frequete, freponse; 
      	
   179	    frequete = msgget(CLEF_REQUETES, 0700 | IPC_CREAT); 
   180	    if (frequete == -1) { perror("msgget"); return (EXIT_FAILURE); } 
      	
   181	    freponse = msgget(CLEF_REPONSES, 0700 | IPC_CREAT); 
   182	    if (freponse == -1) { perror("msgget"); return (EXIT_FAILURE); } 
      	
   183	    msg.mtype = getpid(); 
   184	    strcpy(msg.mtext, "Hello"); 
   185	    res = msgsnd(frequete, & msg, strlen(msg.mtext) + 1, 0); 
   186	    if (res == -1) { perror("msgsnd"); exit(0); } 
      	
   187	    res = msgrcv(freponse, & msg, LG_MAX, getpid(), 0); 
   188	    if (res == -1) { perror("msgrcv"); exit(0); } 
      	
   189	    printf("result : %s\n", msg.mtext); 
   190	    return (EXIT_SUCCESS); 
   191	    }
      	
   192	////////////////////////////////////////////////////////////////////////////
      	
   193	/*
   194	** speak.c -- writes into a FIFO
   195	*/
      	
   196	#include <stdio.h>
   197	#include <stdlib.h>
   198	#include <errno.h>
   199	#include <string.h>
   200	#include <fcntl.h>
   201	#include <sys/types.h>
   202	#include <sys/stat.h>
   203	#include <unistd.h>
      	
   204	#define FIFO_NAME "fifo_main"
      	
   205	int main(void)
   206	{
   207		char s[300];
   208		int num, fd;
      	
   209		mknod(FIFO_NAME, S_IFIFO | 0666, 0);
      	
   210		printf("waiting for readers...\n");
   211		fd = open(FIFO_NAME, O_WRONLY);
   212		printf("got a reader--type some stuff\n");
      	
   213		while (gets(s), !feof(stdin)) {
   214			if ((num = write(fd, s, strlen(s))) == -1)
   215				perror("write");
   216			else
   217				printf("speak: wrote %d bytes\n", num);
   218		}
      	
   219		return 0;
   220	}
      	
   221	////////////////////////////////////////////////////////////////////////////
      	
   222	/*
   223	** tick.c -- reads data from a FIFO
   224	*/
      	
   225	#include <stdio.h>
   226	#include <stdlib.h>
   227	#include <errno.h>
   228	#include <string.h>
   229	#include <fcntl.h>
   230	#include <sys/types.h>
   231	#include <sys/stat.h>
   232	#include <unistd.h>
      	
   233	#define FIFO_NAME "fifo_main"
      	
   234	int main(void)
   235	{
   236		char s[300];
   237		int num, fd;
      	
   238		mknod(FIFO_NAME, S_IFIFO | 0666, 0);
      	
   239		printf("waiting for writers...\n");
   240		fd = open(FIFO_NAME, O_RDONLY);
   241		printf("got a writer\n");
      	
   242		do {
   243			if ((num = read(fd, s, 300)) == -1)
   244				perror("read");
   245			else {
   246				s[num] = '\0';
   247				printf("tick: read %d bytes: \"%s\"\n", num, s);
   248			}
   249		} while (num > 0);
      	
   250		return 0;
   251	}
      	
   252	////////////////////////////////////////////////////////////////////////////
      	
   253	/* Processus ecrivain */
   254	#include <sys/ipc.h>
   255	#include <sys/shm.h>
   256	#include <sys/sem.h>
   257	#include <stdio.h>
   258	#include <stdlib.h>
   259	#include <string.h>
      	
   260	#define CLEF 666
      	
   261	#define LONGUEUR_SEGMENT 512 
      	
      	
   262	int main(int argc,char *argv[])
   263	{
   264	  int semaphores;
   265	  int memoirePartagee;
   266	  struct sembuf manipSemaphores[2];
   267	  char *attacheMoi;
      	
   268	  
      	
   269	  if ((memoirePartagee=shmget(CLEF,LONGUEUR_SEGMENT,IPC_CREAT|0666)) == -1)
   270	  {
   271	    puts("Impossible de creer le segment de memoire partagee");
   272	    exit(1);
   273	  }
      	
      	
   274	  if ((semaphores=semget(CLEF,2,IPC_CREAT|0666)) == -1)
   275	  {
   276	    puts("Impossible de creer les semaphores");
   277	    exit(1);
   278	  }
      	
   279	  /* Les deux operations d'initialisation des semaphores sont faites
   280	     en meme temps */
      	
   281	  manipSemaphores[0].sem_num=0; 
   282	  manipSemaphores[0].sem_op=1;
      	
   283	  manipSemaphores[1].sem_num=1;
   284	  manipSemaphores[1].sem_op=1;
      	
   285	  semop(semaphores,manipSemaphores,2);
      	
   286	  /* Operation P(1) sur le premier semaphore => prise de ressource sur la 
   287	     memoire partagee */
      	
   288	  manipSemaphores[0].sem_num=0;
   289	  manipSemaphores[0].sem_op=-1;
      	
   290	  semop(semaphores,manipSemaphores,1);
      	
   291	  puts("Je prends la ressource");fflush(stdout);
      	
   292	  attacheMoi=shmat(memoirePartagee,NULL,0);
      	
      	
   293	  //if ((int)(attacheMoi)==-1)
   294	  if (attacheMoi==(void*)-1)
   295	  {
   296	    puts("Impossible d'attacher !");
   297	    exit(1);
   298	  }
   299	  else
   300	  {
   301	    printf("Adresse de l'attachement : %p \n",attacheMoi);
   302	    strcpy(attacheMoi,"Message a l'adresse de l'autre processus !");
   303	    shmdt(attacheMoi);
   304	    
   305	    /* Operation V(1) sur le premier semaphore => liberation de la ressource
   306	       memoire partagee */
   307	    
   308	    manipSemaphores[0].sem_num=0;
   309	    manipSemaphores[0].sem_op=1;
   310	    semop(semaphores,manipSemaphores,1);
   311	  }
      	
      	
   312	  puts("Attente de l'autre processus");
   313	  fflush(stdout);
      	
   314	  /* Operation Z sur le second semaphore */
      	
   315	  manipSemaphores[0].sem_num=1;
   316	  manipSemaphores[0].sem_op=0;
   317	  semop(semaphores,manipSemaphores,1);
   318	  
      	
   319	  puts("Debloque !");
   320	  fflush(stdout);
   321	 
   322	  /* Suppression des IPC */
      	
   323	  semctl(semaphores,0,IPC_RMID);
   324	  
   325	  shmctl(memoirePartagee,IPC_RMID,0);
   326	  
   327	  
   328	  return 0;
      	
   329	}
      	
   330	////////////////////////////////////////////////////////////////////////////
      	
   331	/* Processus lecteur */
      	
   332	#include <sys/ipc.h>
   333	#include <sys/shm.h>
   334	#include <sys/sem.h>
   335	#include <stdio.h>
   336	#include <stdlib.h>
   337	#include <string.h>
      	
   338	#define CLEF 666
      	
   339	#define LONGUEUR_SEGMENT 512 
      	
      	
   340	int main(int argc,char *argv[])
   341	{
   342	  int semaphores;
   343	  int memoirePartagee;
   344	  struct sembuf manipSemaphores;
   345	  char *attacheMoi;
   346	 
      	
   347	  if ((memoirePartagee=shmget(CLEF,LONGUEUR_SEGMENT,0600)) == -1)
   348	  {
   349	    puts("Impossible d'acceder au segment de memoire partagee");
   350	    exit(1);
   351	  }
      	
      	
   352	  if ((semaphores=semget(CLEF,2,0600)) == -1)
   353	  {
   354	    puts("Impossible d'acceder aux semaphores");
   355	    exit(1);
   356	  }
   357	  
   358	  /* Operation P(1) => on demande à accéder à la ressource */
      	
   359	  manipSemaphores.sem_num=0;
   360	  manipSemaphores.sem_op=-1;
      	
   361	  semop(semaphores,&manipSemaphores,1);
      	
   362	  puts("Je demande a acceder a la ressource");fflush(stdout);
      	
   363	  attacheMoi=shmat(memoirePartagee,NULL,0);
      	
      	
   364	  if (attacheMoi==(void*)-1)
   365	  {
   366	    puts("Impossible d'attacher !");
   367	    exit(1);
   368	  }
   369	  else
   370	  {
   371	    printf("Adresse de l'attachement : %p \n",attacheMoi);
   372	    puts("Contenu de la memoire a l'attachement ");
   373	    puts(attacheMoi);
   374	    shmdt(attacheMoi);
   375	    manipSemaphores.sem_num=0;
   376	    manipSemaphores.sem_op=1;
   377	    semop(semaphores,&manipSemaphores,1);
   378	  }
   379	 
      	
   380	  puts("Deblocage de l'autre processus");
   381	  fflush(stdout);
      	
   382	  /* Debloquer le semaphore en attente se fait 
   383	     a l'aide d'une operation prise de ressource P(1) car la valeur
   384	     courante de celui-ci est 1*/
      	
   385	  manipSemaphores.sem_num=1;
   386	  manipSemaphores.sem_op=-1;
   387	  semop(semaphores,&manipSemaphores,1);
   388	  
   389	  
   390	  return 0;
   391	}
