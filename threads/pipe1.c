/*
 * pipe.c
 *
 * Simple demonstration of a pipeline. main() is a loop that
 * feeds the pipeline with integer values. Each stage of the
 * pipeline increases the integer by one before passing it along
 * to the next. Entering the command "=" reads the pipeline
 * result. (Notice that too many '=' commands will hang.)
 */
#include <pthread.h>
#include "errors.h"
#include <time.h>
#include <unistd.h>

/*
 * Internal structure describing a "stage" in the
 * pipeline. One for each thread, plus a "result
 * stage" where the final thread can stash the value.
 */
static pthread_mutex_t     stage_mutex[4] = { PTHREAD_MUTEX_INITIALIZER, PTHREAD_MUTEX_INITIALIZER, PTHREAD_MUTEX_INITIALIZER, PTHREAD_MUTEX_INITIALIZER,   } ;          /* Protect data */
static pthread_cond_t      stage_avail[4] = { PTHREAD_COND_INITIALIZER, PTHREAD_COND_INITIALIZER, PTHREAD_COND_INITIALIZER, PTHREAD_COND_INITIALIZER } ;          /* Data available */
static pthread_cond_t      stage_ready[4] = { PTHREAD_COND_INITIALIZER, PTHREAD_COND_INITIALIZER, PTHREAD_COND_INITIALIZER, PTHREAD_COND_INITIALIZER } ;          /* Ready for data */
int                 stage_data_ready[4];     /* Data present */
long                stage_data[4];           /* Data to process */
pthread_t           stage_thread[4];         /* Thread for stage */

void heavyComputation()
{
        volatile unsigned long long i;

        for (i=0;i<1000000000ULL;i++);

	printf("ID: %lu, CPU: %d\n", pthread_self(), sched_getcpu());
}

/*
 * Internal function to send a "message" to the
 * specified pipe stage. Threads use this to pass
 * along the modified data item.
 */
int pipe_send (int stageId, long data)
{
    int status;

//printf("pipe_send %d %d\n",stageId,(int)(long)data);

    status = pthread_mutex_lock (&stage_mutex[stageId]);
    if (status != 0)
        return status;
    /*
     * If there's data in the pipe stage (stage_data_ready=1), then wait for it
     * to be consumed before accepting new data.
     */
    while (stage_data_ready[stageId]) {
        status = pthread_cond_wait (&stage_ready[stageId], &stage_mutex[stageId]);
        if (status != 0) {
            pthread_mutex_unlock (&stage_mutex[stageId]);
            return status;
        }
    }

    /*
     * If we are here, the stage can process the new data and tell the next stage the new data is available
     */
    stage_data[stageId] = data;
    stage_data_ready[stageId] = 1;

//printf("pipe_send data=%d\n",(int)data);

    status = pthread_cond_signal (&stage_avail[stageId]);
    if (status != 0) {
        pthread_mutex_unlock (&stage_mutex[stageId]);
        return status;
    }
    status = pthread_mutex_unlock (&stage_mutex[stageId]);
    return status;
}

void *input_stage (void *arg)
{
	int stageId=(int)(long)arg;
	long value=0;

//printf("input_stage %d\n",stageId);
	while (1)
	{
		pipe_send(1,value);
		value++;
	}

	return NULL;
}

void *output_stage (void *arg)
{
	int stageId=(int)(long)arg;
	long result;
  	time_t rawtime;
  	struct tm * timeinfo;


//printf("output_stage %d\n",stageId);
	while (1)
	{
    		pthread_mutex_lock (&stage_mutex[stageId]);
    		while (!stage_data_ready[stageId])
        		pthread_cond_wait (&stage_avail[stageId], &stage_mutex[stageId]);
    		result = stage_data[stageId];
  		time ( &rawtime );
  		timeinfo = localtime ( &rawtime );
  		printf ( "Current local time and date: %s calcul %d\n", asctime (timeinfo), (int)(long)result );

    		stage_data_ready[stageId] = 0;
    		pthread_cond_signal (&stage_ready[stageId]);
    		pthread_mutex_unlock (&stage_mutex[stageId]);
	}

	return NULL;
}

void *pipe_stage (void *arg)
{
    int stageId = (int)(long)arg;
    int nextStageId = stageId+1;
    int status;

printf("pipe_stage %d\n",stageId);

    status = pthread_mutex_lock (&stage_mutex[stageId]);
    if (status != 0)
        err_abort (status, "Lock pipe stage");
    while (1) {
        while (stage_data_ready[stageId] != 1) {
            status = pthread_cond_wait (&stage_avail[stageId], &stage_mutex[stageId]);
            if (status != 0)
                err_abort (status, "Wait for previous stage");
        }

	heavyComputation();
	//heavyComputation();

        pipe_send (nextStageId, stage_data[stageId] + 1);
        stage_data_ready[stageId] = 0;

//printf("stage %d pret a recevoir\n",stageId);

        status = pthread_cond_signal (&stage_ready[stageId]);
        if (status != 0)
            err_abort (status, "Wake next stage");
    }
    /*
     * Notice that the routine never unlocks the stage->mutex.
     * The call to pthread_cond_wait implicitly unlocks the
     * mutex while the thread is waiting, allowing other threads
     * to make progress. Because the loop never terminates, this
     * function has no need to unlock the mutex explicitly.
     */
}

int pipe_create (int stages)
{
	cpu_set_t cpus;
	pthread_attr_t attr;
	int cpu_index=0;

    	int i;
    	int status;

    	for (i=0; i < stages; i++) 
        	stage_data_ready[i] = 0;

	status = pthread_create(&stage_thread[0], NULL, input_stage, (void*)0);
       	if (status != 0)
       		err_abort (status, "can't create thread 0");
	status = pthread_create(&stage_thread[1], NULL, pipe_stage, (void*)1);
       	if (status != 0)
       		err_abort (status, "can't create thread 1");
	status = pthread_create(&stage_thread[2], NULL, pipe_stage, (void*)2);
       	if (status != 0)
       		err_abort (status, "can't create thread 2");
	status = pthread_create(&stage_thread[3], NULL, output_stage, (void*)3);
       	if (status != 0)
       		err_abort (status, "can't create thread 3");

	pthread_join(stage_thread[0],NULL);
	pthread_join(stage_thread[1],NULL);
	pthread_join(stage_thread[2],NULL);
	pthread_join(stage_thread[3],NULL);
    	return 0;
}

int main (int argc, char *argv[])
{

	pipe_create(4);
	return 0;
}
